
<<<  콜백 함수 >>>


 함수도 하나의 자료형이다. 따라서 다른 함수의 매개변수로 전달할 수 있다.
 이렇게 매개변수로 전달하는 함수를 '콜백 함수'라고 한다.

    <====================예시=======================>
    function callThreeTimes(callback){
        for(let i=0; i<3 ; i++){
            callback(i)
        }
    }

    function print(i){
        console.log('${i}번째 함수 호출')
    }

    callThreeTimes(print)

    <--- 출력 --->
    0번째 함수 호출
    1번째 함수 호출
    2번째 함수 호출

    <====================끝=========================>
    <====================예시=======================>
    function callThreeTimes(callback){
        for(let i=0; i<3 ; i++){
            callback(i)
        }
    }


    callThreeTimes(function(i){
        console.log('${i}번째 함수 호출')
    })

    <--- 출력 --->
    0번째 함수 호출
    1번째 함수 호출
    2번째 함수 호출

    <====================끝=========================>






<<< 1.1 forEach() 함수 >>>
 배열이 갖고 있는 함수로써 단순하게 
 배열 내부의 요소를 사용해서 콜백 함수를 호출.

 function (value, index, array){ }


    <====================예시=======================>
    const numbers = [1,2,3,4,5]

    numbers.forEach(function(value, index, array){
        console.log('${index}번째 요소 ${value}')
    })
    <====================끝=========================>






<<< 1.2 map() 함수 >>>
 map() 메소드는 콜백 함수에서 리턴한 값들을 기반으로 새로운 배열을 만듦.

    <====================예시=======================>
    let numbers = [1,2,3,4,5]

    numbers = numbers.map(function(value, index, array){
        return value * value
    })
    numbers.forEach(console.log)
    <====================끝=========================>




<<< 1.3 filter() 함수 >>>
 콜백 함수에서 리턴값이 true인 것들만 모아서 새로운 배열을 만드는 함수.

    <====================예시=======================>
    const numbers.[0,1,2,3,4,5]
    const evenNumbers = numbers.filter( function (value){
        return value%2 === 0
    )}
    evenNumbers.forEach(console.log)
    <====================끝=========================>



 <<< 1.4 화살표 함수 >>>
  단순한 형태의 콜백 함수를 쉽게 입력하고자 '화살표 함수'라는 새로운 함수 생성 방법을 사용.
  function 키워드 대신 화살표(=>)를 사용하며, 다음과 같은 형태로 생성하는 간단한 함수.
(매개변수) => {

}

(매개변수) => 리턴값

*this 키워드와는 다르다.

    <====================예시=======================>
    const array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    array.map((value) => value * value)

    <---출력--->
    (10) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
    <====================끝=========================>

    <====================예시=======================>
    let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    numbers
        .filter((value) => value % 2 === 0)
        .map((value) => value * value)
        .forEach((value) => {
            console.log(value)
        })

    <--- 출력 --->
    0
    4
    16
    36
    64

    <====================끝=========================>


<<< 1.5 타이머 함수 >>>
 특정 시간마다 / 특정 시간 이후에 콜백 함수를 호출할 수 있는 타이머 함수가 있다.

  - setTimeout(함수, 시간)
  - setInterval(함수, 시간)

 종료 요청

  - clearTimeout(타이머ID)
  - clearInterval(타이머ID)

    <====================예시=======================>
    let id
    let count = 0
    id = setInterval(() => {
        console.log('1초마다 실행됩니다.(${count}번째)')
        count++
    }, 1 * 1000)

    setTimeout(() ==> {
        console.log('타이머를 종료합니다.')
        clearInterval(id)
    }, 5 * 1000)

    <--- 출력 --->
    1초마다 실행됩니다.(0번째)
    1초마다 실행됩니다.(1번째)
    1초마다 실행됩니다.(2번째)
    1초마다 실행됩니다.(3번째)
    1초마다 실행됩니다.(4번째)
    타이머를 종료합니다.
    <====================끝=========================>
    



<!-- 함수 고급 +alpha -->

<< 1. 즉시 호출 함수 >>
 익명 함수를 호출하고 즉시 호출하는 패턴을 많이 볼 수 있다. 이는 HTML 에서 
 <script>태그로 코드를 불러오면서 변수가 중복되어 충돌할 수 있기 때문이다.

 - 변수가 존재하는 범위를 Scope 이라고 한다. 같은 단계에 있는 변수가 중복으로 사용되거나 할당이되면
 충돌이 일어난다.
 - 따라서 중괄호 {} 를 넣어 블록을 만들어 주는데, 이와 같이 중괄호를 통해 내부 변수와 외부변수를
 구분하는 방법을 '섀도잉' 이라고 한다.

<< 2. 즉시 호출 함수 문제 해결하기 >>
 - var 키워드를 사용


    <====================예시=======================>
    <!-- 다른 곳에서 가져온 코드 -->

    <!-- 내가 쓴 코드 -->
    (function() {
        let pi = 3.14
        console.log(pi)
    })()
    <====================끝=========================>

<< 3. 엄격 모드 >>
 'use strict'
 엄격하게 검사.


<< 4. 익명 함수와 선언적 함수의 차이 >>
 while : 조건을 중심으로 반복
 for   : 횟수/배열을 중심으로 반복

 익명 함수 : 함수 선언 -> 함수 할당 -> 함수 호출
 선언적 함수 : 함수 호출 -> 함수 선언 및 할당

 - 익명 함수와 선언적 함수의 조합
  선언적 함수는 먼저 생성, 이후 순차적인 코드 진행하며 익명 함수를 생성함.

    <====================예시=======================>
    함수 = function(){
        console.log(1)
    }

    function 함수(){
        console.log(2)
    }

    함수()

    <--- 출력 --->
    1

    <====================끝=========================>


 블록이 다를 경우 선언적 함수
  -> 선언적 함수의 실행 흐름을 예측하는 것이 힘들다.

    <====================끝=========================>
    <script>
        선언적함수()
        function 선언적함수(){
            console.log(1)
        }
    </script>
    <script>
        function 선언적함수(){
            console.log(2)
        }
    </script>
    <script>
        선언적함수()
    </script>

    <--- 출력 --->
    1
    2

    <====================끝=========================>



    